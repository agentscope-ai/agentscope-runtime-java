# 沙箱使用最佳实践

> **建议阅读前提**：本文档假设你已熟悉沙箱的基本概念与基础用法。在深入以下内容前，强烈建议先完成上一节关于[ 沙箱基础 ](sandbox.md)的教程，以便更好地理解本节所讨论的高级部署策略。

在实际生产环境中，沙箱的部署与管理方式需根据系统规模、并发需求以及资源隔离要求进行合理设计。不同的运行时（Runtime）部署架构对沙箱生命周期管理、资源复用机制及后端存储提出了不同挑战。以下将从单机到分布式场景，分层次介绍沙箱使用的最佳实践。

## 单机单 Runtime 场景

### 适用场景

适用于开发调试、轻量级服务或单实例应用，系统中仅存在一个 Runtime 进程，且无跨进程共享沙箱的需求。

### 推荐架构

* **沙箱管理**：使用基于内存的 `SandboxMap` 实现沙箱状态管理。

* **容器后端**：直接对接本地 Docker Daemon，采用基础 Docker 驱动作为容器运行时后端。

### 实践建议

在此场景下，由于不存在多个 Runtime 实例对同一沙箱的并发访问与复用问题，无需引入外部状态存储。内存级别的沙箱映射足以满足性能与一致性要求，部署简单、启动快速，适合快速迭代与本地验证。

> **注意**：该模式不具备跨进程或跨节点的可扩展性，不适用于多实例部署环境。

## 单机多 Runtime 场景

### 适用场景

适用于高并发、多租户或模块化架构的单机部署，系统中启动多个 Runtime 实例以并行处理任务，但所有实例共享同一台主机资源。

### 核心挑战

多个 Runtime 实例可能同时尝试访问、复用或销毁同一个沙箱实例，若仍使用本地内存管理，将导致状态不一致、资源竞争或重复创建等问题。

### 推荐架构

* **状态管理**：**必须引入 Redis** 作为全局共享的沙箱元数据存储中心，确保所有 Runtime 实例能一致地读取和更新沙箱状态。

* **容器后端**：所有 Runtime 实例通过同一个 `containerClient` 共享访问后端，实现沙箱实例的统一调度与复用。

### 实践建议

通过 AgentScope Runtime Java 提供的 RedisSandboxMap 实现沙箱的引用计数与生命周期管理，避免竞态条件。

## 多机多 Runtime 场景

### 适用场景

适用于分布式系统、弹性伸缩集群或微服务架构，多个 Runtime 实例分布在不同主机上，需协同管理沙箱资源。

### 核心挑战

除了状态一致性外，还需解决容器后端的可达性与网络隔离问题。不同节点可能无法直接访问彼此的容器运行时，导致沙箱无法复用或管理失效。

### 推荐方案

根据各节点是否能访问到统一的容器后端，分为以下两种部署策略：

#### 1. 所有节点可访问同一容器后端（集中式容器管理）

* **架构描述**：所有 Runtime 节点通过网络（如 Docker TCP API 或 Kubernetes CRI）访问同一个远程容器运行时（如远程 Docker Daemon 或 Kubernetes 集群）。

* **管理方式**：与“单机多 Runtime”一致，**使用 AgentScope Runtime Java 提供的 RedisSandboxMap 统一管理沙箱状态**，所有节点通过共享后端操作容器。

* **优势**：架构统一，管理简单，沙箱可被任意节点复用。

* **注意**：需保障容器后端的高可用与网络稳定性，避免单点故障。

#### 2. 节点无法访问同一容器后端（分布式容器环境）

* **架构描述**：各节点拥有独立的容器运行时（如各自运行 Docker），无法直接操作其他节点的容器。

* **推荐方案**：采用 **远程Runtime（Remote Runtime）架构**。

* **实施方式**：

  * 在能够访问容器后端的机器上部署一个专用的 **Runtime 代理进程**（Sandbox Manager）。

  * 其余节点配置为 **远程模式（Remote Mode）**，通过 **SandboxService** 中内置的远程连接模式连接该代理，委托其创建、管理与复用沙箱。

  * 所有沙箱操作请求被转发至统一入口，实现逻辑集中、物理分布的管理架构。

通过合理选择上述方案，可有效平衡系统复杂性、性能与可扩展性，为不同规模的应用提供安全、高效、可复用的沙箱运行环境。